# 操作系统

## 调度


## 内存管理

## I/O

## 文件系统

## 虚拟化

## 调试与监控


### 调试工具
1、gdb调试

### 监控工具
gprof、perf、strace、valgrind
ebpf


<!-- 1、进程与线程区别
2、线程同步的方式：互斥锁、自旋锁、读写锁、条件变量
3、互斥锁与自旋锁的底层区别
互斥锁：当阻塞时，会将线程从运行队列中移除，直到锁释放后再加入运行队列，对应的上下文切换开销大
4、孤儿进程与僵尸进程
孤儿进程：父进程先结束，子进程还在运行
僵尸进程: 子进程退出后，父进程未调用waitpid()回收其资源
5、死锁及避免
比如，避免占用一个资源的时候等待另外一个资源，具体的根据实际情况而定
6、多线程与多进程比较
7、进程间通信：PIPE、FIFO、消息队列、信号量、共享内存、socket
8、管道与消息队列对比
管道适合于父子进程间或者有亲缘关系之间的简单的进程间通信
消息队列是通过内核传递数据的机制，适合不相干的进程间进行异步通信
9、fork进程的底层：读时共享，写时复制
当调用fork创建子进程时，操作系统会将父进程的地址空间完全复制一份。一开始的时候共享物理页，当父进程或者子进程尝试写数据时，操作系统会触发写时复制操作，操作系统会为涉及到的物理页创建一份副本。
核心的作用是使fork创建子进程的开销最小化
10、线程上下文切换的流程

- 保存当前线程上下文
  当操作系统决定要切换到另一个线程时，首先需要保存当前线程的上下文信息，包括程序计数器（PC）、寄存器状态、堆栈指针等。这些信息会被保存到当前线程的内核态堆栈或者内核数据结构中。
- 切换到目标线程的上下文
  操作系统根据调度算法选择下一个要执行的线程，然后将目标线程的上下文信息加载到CPU寄存器中，包括程序计数器（PC）、寄存器状态、堆栈指针等。
- 更新内存管理单元（MMU）
  如果涉及到虚拟内存的切换，操作系统可能还需要更新内存管理单元（MMU）中的页表等信息，以确保新的线程能够访问正确的内存空间。
- 切换完成，执行目标线程
  上下文切换完成后，CPU开始执行目标线程的代码，从目标线程上次执行的位置继续执行。
  11、进程上下文切换的流程
- 保存当前进程状态
  当操作系统决定要切换到另一个进程时，首先需要保存当前运行进程的上下文信息。这包括程序计数器（PC）、寄存器状态、堆栈指针、处理器状态寄存器等。这些信息会被保存到当前进程的内核栈或者内核数据结构中。
- 选择目标进程
  根据调度算法，操作系统选择下一个要执行的进程。
- 切换到目标进程的上下文
  操作系统将目标进程的上下文信息加载到CPU寄存器中，包括程序计数器（PC）、寄存器状态、堆栈指针等。
- 更新内存管理单元（MMU）
  如果涉及到虚拟内存的切换，操作系统可能还需要更新内存管理单元（MMU）中的页表等信息，以确保新的进程能够访问正确的内存空间。
- 切换完成，执行目标进程
  ：上下文切换完成后，CPU开始执行目标进程的代码，从目标进程上次执行的位置继续执行。
  12、进程的调度算法
  公平调度算法：找到虚拟运行时间最短的任务进行执行
  13、阻塞IO与非阻塞IO
  阻塞IO：进程被阻塞，进入阻塞状态，待IO操作完成后进入Ready或者运行状态
  非阻塞IO：请求后立即退出，如果需要结果，需要通过轮询的方式获取
  14、同步与异步的概念
  15、静态链接与动态链接的过程
  静态链接是在编译期间：将静态库和程序代码打包到同一个文件中
  动态链接实在运行的时候，因为动态链接中可执行文件只包含程序自身的代码，对于调用的库，只有引用的信息，而不包含实际的库代码。16、虚拟内存概念（非常重要）
  17、MMU地址翻译的具体流程
  虚拟地址：指定页面+页面内的偏移量
- MMU根据虚拟地址查找页表
- 页表中包含物理页面的信息，
- 根据物理页面的信息加页内偏移量获取真实物理内存的位置
  18、缺页处理过程
  当程序试图访问不在内存中的数据或者指令时，CPU会触发缺页异常。操作系统会捕获这个异常，并触发缺页中断处理程序。
  19、缺页置换算法：最久未使用算法、先进先出算法、最佳置换算法

参考书籍：《Unix环境高级编程》、《Linux多线程服务器端编程》
ps:操作系统的内容看起来不是很多，实际上每个问题答案的底层原理要弄懂还是很考验基本功的。比如：互斥锁与自旋锁的区别，实际上涉及到阻塞时线程的状态是不一样的。互斥锁阻塞的线程是挂起的，此时系统会优先执行其它可执行的线程，就会将阻塞的线程切换到可执行线程，而当临界区执行的时间非常短时，此时线程切换频繁、开销较大，此时就会采用自旋锁的方式，让阻塞的线程处于忙等状态。 -->

# 参考