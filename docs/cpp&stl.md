# C++

## 多态

### 虚表的产生以及虚函数的访问过程

虚表是编译阶段生成的一个全局只读的函数指针数组，如果是派生类，如果重写了基类的虚函数，派生类虚表对应位置会替换为自身的函数指针

虚表指针（vptr) 是每个含虚函数的对象隐含的成员变量（通常在对象的最开头），用来指向所属的需函数表。（**vptr 赋值** ：在**构造函数的初始化列表执行完毕后，构造函数体执行之前）**

调用虚函数的访问流程： 取vptr -> 找vtable -> 根据偏移量找函数地址 -> 执行函数

### 多态基类声明虚虚构函数

基类指针指向派生类对象时，若析构函数非虚，会导致派生类析构函数不执行，引发内存泄露

## **新特性**

### **右值引用**


# stl

## c++常见问题

### 容器以及对应的数据结构

vector：连续内存

deque：分段连续

map：哈希表

list：双向循环链表

set: 红黑树

unordered_map: 红黑树

### vector扩容机制

添加元素且当前容量不足以容纳新元素时，就会触发扩容

### vector push_back和emplace_back的区别

push_back：先创建一个完整的对象，再将这个对象拷贝、移动到vector的内存中

emplace_back: 直接在vector的内存空间就地构造对象，跳过“先创建再拷贝/移动”的步骤

### 迭代器失效

容器因 **增删元素、内存扩容** ，导致原迭代器指向 **无效 / 错误内存** ，无法正常遍历、访问元素，即为迭代器失效。

场景：**vector/string 等连续内存容器**

* 插入触发 **扩容** ：所有迭代器直接失效；
* 中间插入 / 删除：插入 / 删除位置**之后**的迭代器失效。

2. **list 链表容器**
   仅**被删除元素**的迭代器失效，其余不受影响。
3. **map/set 等关联容器**
   仅**被删除节点**的迭代器失效，其他迭代器均有效。

### std::move的实现原理

一个类型转换工具，将左值强制转换为右值引用，让编译器认为这个对象“可以被移动”

### atomic变量的内存序

背景：编译器优化导致程序实际执行顺序跟代码顺序不完全一致

比如 x = 0 , y = 0

thread 1: x=1; y =1

thread 2 while(y!=1); assert(x == 1) // 可能会失败

以及现代计算机体系结构的特点：一个核赋值后在另一个核心中并不立马可见

### 如何防止死锁

导致死锁的4个必要条件：环形依赖（按固定顺序获取资源） ； 互斥（ 不可抢占（支持抢占）；持有且等待（一次性获取资源；获取一个资源后立刻释放另一个）

# 参考

[https://wizardforcel.gitbooks.io/effective-cpp/content/index.html](https://wizardforcel.gitbooks.io/effective-cpp/content/index.html)  C++ 进阶的核心指南， “避坑 + 最佳实践“

[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines]([https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines]())  指导开发者编写安全、高效、易维护的 C++ 代码，而非替代 C++ 标准或教程
